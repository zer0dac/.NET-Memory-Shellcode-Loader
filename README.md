# Disclaimer: 

This tool is intended for educational and ethical hacking purposes only. Always obtain permission before testing any system or application. The developers are not responsible for any misuse or damage caused by this tool.

# Description:

This project is a Proof of Concept (PoC) for an In-Memory Shellcode Executor developed in C#. It is designed to dynamically retrieve, decrypt, and execute a shellcode payload—specifically one generated by the Donut tool—from a remote Command and Control (C2) server.

# Key Features:

* Fileless Execution: The shellcode is loaded directly into memory at runtime via an HTTP request, bypassing disk-based detection.

* Encrypted Payload Delivery: The payload is transferred over the network encoded in Base64 and encrypted using AES-CBC (with a static key and IV) by the C2 server.

* In-Memory Execution: Leverages Windows API functions (VirtualAlloc, VirtualProtect, CreateThread) via P/Invoke to allocate executable memory and run the shellcode within the current process.

* Decoupled C2: Uses a simple Python Flask server to simulate a C2 backend, handling encryption and serving the payload as a JSON response.

# Execution Flow:

1- C# Fake App for Verification(C2ExecutorCheck.cs): The primary goal of this application is to confirm that the executor has been executed successfully and to receive
feedback from the C2 server. 

Build it first of all:

<img width="486" height="337" alt="image" src="https://github.com/user-attachments/assets/0b550ed7-897c-40d1-a9ea-5d36bf24aae2" />

2- Generating Shellcode with Donut(https://github.com/TheWover/donut): 

After building it, donut it to exe to shellcode convert before sending it. 

<img width="1128" height="297" alt="image" src="https://github.com/user-attachments/assets/0e93652b-4816-4c68-ad54-3d762829263d" />

Donut Output:

<img width="1129" height="227" alt="image" src="https://github.com/user-attachments/assets/a3991a38-161d-4a12-8712-ccf8a75dd78a" />

We will copy this shellcode to test.txt, which is used by flask server(Basic C2 server).

3- Used python flask for C2 Server(c2MiniBackend.py):

* read_hex_file(file_path) reads a hex-encoded shellcode file and cleans unnecessary characters (0x, ,).
* Converts the cleaned hex string into raw bytes for encryption.
* encrypt_hex_file(file_path) uses AES-CBC encryption with a static key and IV.
* Applies PKCS7 padding before encryption to ensure proper block alignment.
* Encodes the encrypted shellcode in Base64 for easy transmission.
* Flask server runs on port 5000 to serve the encrypted payload dynamically.
* /get-base64-file endpoint returns the encrypted shellcode as a JSON response.
* Allows the C# executor to fetch, decrypt, and execute the payload in memory.

Running Flask Server:

<img width="1129" height="340" alt="image" src="https://github.com/user-attachments/assets/77449a59-6604-48a3-9afe-fc0fadb44b29" />

4- The In-Memory Executor:

* The GetBase64FromPythonServerAsync() function sends an HTTP GET request to a Flask-based C2 server.
* It retrieves a Base64-encoded, AES-encrypted payload from the endpoint (/get-base64-file).
* The function extracts the payload from the JSON response and returns it as a string.
* Uses AES-CBC encryption with a predefined key and IV.
* Converts the Base64-encoded payload into raw bytes.
* Decrypts the payload into executable shellcode.
* Allocate Memory and Write Decrypted Payload
* VirtualAlloc() allocates a memory region to store the decrypted shellcode.
* Marshal.Copy() copies the decrypted shellcode into the allocated memory.
* VirtualProtect() modifies memory permissions to make it executable.
* CreateThread() creates a new thread, pointing to the allocated shellcode.
* WaitForSingleObject() waits for the execution to complete, ensuring persistence.

Built in the same way as the fake C# application.

5- Running executor on victim system:

<img width="1127" height="585" alt="image" src="https://github.com/user-attachments/assets/6c0fe41e-61a9-4f42-8150-1d19e62c15bb" />

Output for debugging, for demonstration purposes only.

6- Result:

When the executor runs on the victim system, the Flask server dynamically encrypts and serves the contents of test.txt as
a shellcode payload, which is then sent to the victim machine. At this stage, the executor loads and executes the shellcode
directly in memory, bypassing disk-based detection. By modifying test.txt, we can dynamically alter the executable that
the C# executor will run. As a proof of concept (PoC), my shellcode was designed to send a GET request back to the Flask
server, confirming successful execution and demonstrating remote control over the payload delivery process.

<img width="1120" height="96" alt="image" src="https://github.com/user-attachments/assets/2fa3cba1-e23d-40e3-9601-02e10a370f26" />
